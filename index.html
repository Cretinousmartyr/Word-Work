<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Word Work Game</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 10px;
    }
    /* Word formation drop boxes at the top */
    #word-boxes {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .drop-box {
      width: 70px;
      height: 70px;
      border: 2px dashed #666;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Dropdown menu for controls */
    #menu-container {
      position: relative;
      display: inline-block;
      margin-bottom: 20px;
    }
    #menu-button {
      padding: 10px 15px;
      font-size: 16px;
    }
    #menu-content {
      display: none;
      position: absolute;
      background-color: #f9f9f9;
      min-width: 160px;
      box-shadow: 0px 8px 16px rgba(0,0,0,0.2);
      z-index: 100;
    }
    #menu-content button {
      width: 100%;
      padding: 10px;
      border: none;
      background: none;
      text-align: left;
      cursor: pointer;
    }
    #menu-content button:hover {
      background-color: #ddd;
    }
    /* Reset bin – drop here to return a letter to its home cell */
    #reset-bin {
      width: 100%;
      height: 50px;
      border: 2px solid #666;
      margin-bottom: 20px;
      text-align: center;
      line-height: 50px;
      color: #666;
    }
    /* Alphabet grid – a fixed grid of letter cells */
    #alphabet-grid {
      display: grid;
      grid-template-columns: repeat(7, 1fr);
      gap: 10px;
    }
    .letter-cell {
      width: 70px;
      height: 70px;
      border: 1px dashed #aaa;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: center;
      /* A subtle background to indicate the cell’s spot */
      background-color: #f0f0f0;
    }
    /* Draggable tile styling */
    .tile {
      width: 70px;
      height: 70px;
      border: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      cursor: pointer;
      user-select: none;
      touch-action: none; /* Helps mobile devices track dragging */
      /* Default pastel red for vowels */
      background-color: #FFC1C1;
      /* When inside a cell we want it to line up, so default to relative */
      position: relative;
      top: 0;
      left: 0;
    }
    /* Pastel blue for consonants */
    .tile.consonant {
      background-color: #C1D4FF;
    }
  </style>
</head>
<body>
  <!-- Word formation area (10 drop boxes) -->
  <div id="word-boxes">
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
  </div>

  <!-- Dropdown menu for controls -->
  <div id="menu-container">
    <button id="menu-button">Menu</button>
    <div id="menu-content">
      <button id="speak-word">Speak Word</button>
      <button id="define-word">Define Word</button>
      <button id="reset-all">Reset All</button>
    </div>
  </div>

  <!-- Reset bin (drag a tile here to return it to its home cell) -->
  <div id="reset-bin">Drag letter here to reset</div>

  <!-- Alphabet grid with one letter cell (and tile) per letter A–Z -->
  <div id="alphabet-grid"></div>

  <script>
    // Only allow one active drag at a time (helps with mobile performance)
    let currentDrag = null;

    // Function to speak text using the Web Speech API
    function speakText(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.speak(utterance);
    }

    // Toggle the dropdown menu visibility
    document.getElementById('menu-button').addEventListener('click', function() {
      const menu = document.getElementById('menu-content');
      menu.style.display = (menu.style.display === 'block') ? 'none' : 'block';
    });

    // Close the dropdown if clicking outside of it
    document.addEventListener('click', function(e) {
      const menuContainer = document.getElementById('menu-container');
      if (!menuContainer.contains(e.target)) {
        document.getElementById('menu-content').style.display = 'none';
      }
    });

    // Create the alphabet grid – one cell per letter
    const alphabetGrid = document.getElementById('alphabet-grid');
    const vowels = ['A', 'E', 'I', 'O', 'U'];
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    letters.forEach(letter => {
      // Create cell
      const cell = document.createElement('div');
      cell.classList.add('letter-cell');
      cell.dataset.letter = letter;

      // Create tile for the letter
      const tile = document.createElement('div');
      tile.classList.add('tile');
      tile.textContent = letter;
      tile.dataset.letter = letter;
      if (!vowels.includes(letter)) {
        tile.classList.add('consonant');
      }
      // Store a reference to the home cell so the tile can be reset
      tile.homeCell = cell;

      // Add pointer event listeners for dragging/tapping
      tile.addEventListener('pointerdown', pointerDown);
      tile.addEventListener('pointermove', pointerMove);
      tile.addEventListener('pointerup', pointerUp);
      tile.addEventListener('pointercancel', pointerUp);

      // Place the tile into its home cell
      cell.appendChild(tile);
      alphabetGrid.appendChild(cell);
    });

    // Utility: return the center point of an element
    function getElementCenter(el) {
      const rect = el.getBoundingClientRect();
      return {
        x: rect.left + rect.width / 2,
        y: rect.top + rect.height / 2
      };
    }

    // --- Drag & Drop Handlers (single active drag only) ---

    function pointerDown(e) {
      if (currentDrag) return; // ignore if already dragging a tile
      e.preventDefault();
      const tile = e.currentTarget;
      currentDrag = {
        tile: tile,
        offsetX: e.clientX - tile.getBoundingClientRect().left,
        offsetY: e.clientY - tile.getBoundingClientRect().top,
        startX: e.clientX,
        startY: e.clientY,
        // Remember its current parent so we can compare later
        originalParent: tile.parentElement
      };
      // Remove the tile from its parent so it can float over the page
      document.body.appendChild(tile);
      tile.style.zIndex = 1000;
      // Use pointer capture to keep tracking even if your finger drifts
      tile.setPointerCapture(e.pointerId);
    }

    function pointerMove(e) {
      if (!currentDrag) return;
      const { tile, offsetX, offsetY } = currentDrag;
      // Position the tile so that your pointer stays at the same offset
      tile.style.left = (e.clientX - offsetX) + 'px';
      tile.style.top = (e.clientY - offsetY) + 'px';
    }

    function pointerUp(e) {
      if (!currentDrag) return;
      const { tile, startX, startY } = currentDrag;
      // Determine if this was a tap (minimal movement)
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const tapThreshold = 5;
      if (distance < tapThreshold) {
        speakText(tile.textContent);
      }
      
      // Get the center of the tile for drop-zone checking
      const tileRect = tile.getBoundingClientRect();
      const tileCenter = {
        x: tileRect.left + tileRect.width / 2,
        y: tileRect.top + tileRect.height / 2
      };

      let dropped = false;

      // Check if dropped in one of the word boxes (only if the box is empty)
      document.querySelectorAll('.drop-box').forEach(box => {
        const rect = box.getBoundingClientRect();
        if (
          tileCenter.x >= rect.left &&
          tileCenter.x <= rect.right &&
          tileCenter.y >= rect.top &&
          tileCenter.y <= rect.bottom
        ) {
          if (box.children.length === 0) {
            // Snap the tile into the word box – let CSS handle layout
            tile.style.position = 'static';
            tile.style.left = '';
            tile.style.top = '';
            tile.style.zIndex = '';
            box.appendChild(tile);
            dropped = true;
          }
        }
      });

      // Check if dropped in the reset bin – return to its home cell
      const resetBin = document.getElementById('reset-bin');
      const binRect = resetBin.getBoundingClientRect();
      if (
        tileCenter.x >= binRect.left &&
        tileCenter.x <= binRect.right &&
        tileCenter.y >= binRect.top &&
        tileCenter.y <= binRect.bottom
      ) {
        const homeCell = tile.homeCell;
        // Clear any existing tile (should be empty)
        homeCell.innerHTML = "";
        homeCell.appendChild(tile);
        tile.style.position = "relative";
        tile.style.left = "";
        tile.style.top = "";
        tile.style.zIndex = "";
        dropped = true;
      }

      // If not dropped in a valid zone, let the tile remain where it is (free-floating)
      tile.releasePointerCapture(e.pointerId);
      currentDrag = null;
    }

    // --- Controls in the Dropdown Menu ---

    // Speak the word formed in the word boxes (left-to-right)
    document.getElementById('speak-word').addEventListener('click', function() {
      let word = "";
      document.querySelectorAll(".drop-box").forEach(box => {
        if (box.children.length > 0) {
          word += box.children[0].textContent;
        }
      });
      if (word) {
        speakText(word);
      }
    });

    // Fetch the definition for the formed word and speak it aloud
    document.getElementById("define-word").addEventListener("click", function() {
      let word = "";
      document.querySelectorAll(".drop-box").forEach(box => {
        if (box.children.length > 0) {
          word += box.children[0].textContent;
        }
      });
      if (word) {
        fetch("https://api.dictionaryapi.dev/api/v2/entries/en/" + word)
          .then(response => response.json())
          .then(data => {
            let definition = "";
            if (Array.isArray(data) && data.length > 0) {
              const meanings = data[0].meanings;
              if (meanings && meanings.length > 0) {
                const definitions = meanings[0].definitions;
                if (definitions && definitions.length > 0) {
                  definition = definitions[0].definition;
                  alert("Definition of " + word + ":\n" + definition);
                  speakText(definition);
                  return;
                }
              }
            }
            alert("Definition not found for " + word);
          })
          .catch(err => {
            alert("Error fetching definition for " + word);
          });
      } else {
        alert("No word formed.");
      }
    });

    // Reset all letters: return every tile back to its home cell and clear the word boxes
    document.getElementById("reset-all").addEventListener("click", function() {
      // Reset each tile in the alphabet grid
      document.querySelectorAll(".tile").forEach(tile => {
        const homeCell = tile.homeCell;
        homeCell.innerHTML = "";
        homeCell.appendChild(tile);
        tile.style.position = "relative";
        tile.style.left = "";
        tile.style.top = "";
        tile.style.zIndex = "";
      });
      // Clear all word boxes
      document.querySelectorAll(".drop-box").forEach(box => {
        box.innerHTML = "";
      });
    });
  </script>
</body>
</html>
