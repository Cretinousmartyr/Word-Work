<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Word Work Game</title>
  <style>
    /* Container for the drop boxes (word formation area) */
    #word-boxes {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .drop-box {
      width: 50px;
      height: 50px;
      border: 2px dashed #666;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    /* Control buttons */
    #controls {
      text-align: center;
      margin-bottom: 20px;
    }
    #controls button {
      margin: 0 10px;
      padding: 10px 15px;
      font-size: 16px;
    }
    /* Letter bank where all the tiles start */
    #letter-bank {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      border: 2px solid #ccc;
      padding: 10px;
      min-height: 150px;
    }
    /* Letter tile styling */
    .tile {
      width: 40px;
      height: 40px;
      border: 1px solid #333;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      cursor: pointer;
      user-select: none;
      /* Initially tiles will be in the document flow; when dragged they become absolute */
      position: relative;
    }
  </style>
</head>
<body>
  <!-- Word boxes (drop zones) -->
  <div id="word-boxes">
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
  </div>
  
  <!-- Control buttons -->
  <div id="controls">
    <button id="speak-word">Speak Word</button>
    <button id="define-word">Define Word</button>
    <button id="reset">Reset</button>
  </div>
  
  <!-- Letter bank (tiles will be generated here) -->
  <div id="letter-bank"></div>
  
  <script>
    // Global object to keep track of active drags (by pointerId)
    const activeDrags = {};

    // Function to speak a given text using the Web Speech API
    function speakText(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.speak(utterance);
    }

    // Pointer event handlers for tiles
    function pointerDown(e) {
      e.preventDefault();
      const tile = e.currentTarget;
      
      // Get the tile's current position (in viewport coordinates)
      const rect = tile.getBoundingClientRect();
      
      // If the tile is currently in a drop box, remove it so that the box becomes empty
      if (tile.parentElement.classList.contains('drop-box')) {
        document.getElementById('letter-bank').appendChild(tile);
        // Set its absolute position so it doesn’t jump
        tile.style.position = 'absolute';
        tile.style.left = rect.left + 'px';
        tile.style.top = rect.top + 'px';
      } else {
        // Even if in the letter bank, set to absolute so it can move freely.
        tile.style.position = 'absolute';
        tile.style.left = rect.left + 'px';
        tile.style.top = rect.top + 'px';
      }
      // Bring tile to the front while dragging
      tile.style.zIndex = 1000;
      
      // Record the pointer’s starting position and the offset within the tile
      activeDrags[e.pointerId] = {
        tile: tile,
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        startX: e.clientX,
        startY: e.clientY,
      };
      tile.setPointerCapture(e.pointerId);
    }

    function pointerMove(e) {
      if (!activeDrags[e.pointerId]) return;
      const dragData = activeDrags[e.pointerId];
      const tile = dragData.tile;
      // Update tile position so that the pointer’s offset is maintained
      tile.style.left = (e.clientX - dragData.offsetX) + 'px';
      tile.style.top = (e.clientY - dragData.offsetY) + 'px';
    }

    function pointerUp(e) {
      if (!activeDrags[e.pointerId]) return;
      const dragData = activeDrags[e.pointerId];
      const tile = dragData.tile;

      // If the pointer didn’t move very far, treat it as a tap to speak the letter.
      const dx = e.clientX - dragData.startX;
      const dy = e.clientY - dragData.startY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      const tapThreshold = 5;
      if (distance < tapThreshold) {
        speakText(tile.textContent);
      }
      
      // Get the center of the tile to check for drop-box collisions.
      const tileRect = tile.getBoundingClientRect();
      const tileCenterX = tileRect.left + tileRect.width / 2;
      const tileCenterY = tileRect.top + tileRect.height / 2;
      
      let droppedInBox = false;
      // Look through all drop boxes and see if the center point is inside one.
      document.querySelectorAll('.drop-box').forEach(box => {
        const boxRect = box.getBoundingClientRect();
        if (tileCenterX >= boxRect.left && tileCenterX <= boxRect.right &&
            tileCenterY >= boxRect.top && tileCenterY <= boxRect.bottom) {
          // Only drop the tile if the box is empty.
          if (box.children.length === 0) {
            // Snap the tile into the box by appending it and letting CSS position it naturally.
            tile.style.position = 'static';
            tile.style.left = '';
            tile.style.top = '';
            tile.style.zIndex = '';
            box.appendChild(tile);
            droppedInBox = true;
          }
        }
      });
      
      // If not dropped in a box, the tile remains where it was dropped.
      tile.releasePointerCapture(e.pointerId);
      delete activeDrags[e.pointerId];
    }

    // Generate the letter tiles (3 copies of each letter A–Z)
    const vowels = ['A', 'E', 'I', 'O', 'U'];
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    const letterBank = document.getElementById('letter-bank');
    letters.forEach(letter => {
      for (let i = 0; i < 3; i++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.textContent = letter;
        // Color vowels a light red and consonants a light blue
        tile.style.backgroundColor = vowels.includes(letter) ? '#ffcccc' : '#ccccff';
        // Add pointer events so that the tile can be dragged or tapped
        tile.addEventListener('pointerdown', pointerDown);
        tile.addEventListener('pointermove', pointerMove);
        tile.addEventListener('pointerup', pointerUp);
        tile.addEventListener('pointercancel', pointerUp);
        letterBank.appendChild(tile);
      }
    });

    // “Speak Word” button: collects letters from the drop boxes (in order) and speaks the word.
    document.getElementById('speak-word').addEventListener('click', function() {
      let word = '';
      document.querySelectorAll('.drop-box').forEach(box => {
        if (box.children.length > 0) {
          word += box.children[0].textContent;
        }
      });
      if (word) {
        speakText(word);
      }
    });

    // “Define Word” button: uses a free dictionary API to look up the word.
    document.getElementById('define-word').addEventListener('click', function() {
      let word = '';
      document.querySelectorAll('.drop-box').forEach(box => {
        if (box.children.length > 0) {
          word += box.children[0].textContent;
        }
      });
      if (word) {
        fetch("https://api.dictionaryapi.dev/api/v2/entries/en/" + word)
          .then(response => response.json())
          .then(data => {
            if (Array.isArray(data) && data.length > 0) {
              const meanings = data[0].meanings;
              if (meanings && meanings.length > 0) {
                const definitions = meanings[0].definitions;
                if (definitions && definitions.length > 0) {
                  alert("Definition of " + word + ":\n" + definitions[0].definition);
                  return;
                }
              }
            }
            alert("Definition not found for " + word);
          })
          .catch(err => {
            alert("Error fetching definition for " + word);
          });
      } else {
        alert("No word formed.");
      }
    });

    // “Reset” button: moves every tile back to the letter bank and clears drop boxes.
    document.getElementById('reset').addEventListener('click', function() {
      const letterBank = document.getElementById('letter-bank');
      document.querySelectorAll('.tile').forEach(tile => {
        tile.style.position = '';
        tile.style.left = '';
        tile.style.top = '';
        tile.style.zIndex = '';
        letterBank.appendChild(tile);
      });
    });
  </script>
</body>
</html>
