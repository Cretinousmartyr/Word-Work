<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Word Work Game</title>
  <style>
    body {
      font-family: sans-serif;
      margin: 0;
      padding: 10px;
    }
    /* Word formation drop boxes (top of page) */
    #word-boxes {
      display: flex;
      justify-content: center;
      margin-bottom: 20px;
    }
    .drop-box {
      width: 70px;
      height: 70px;
      border: 2px dashed #666;
      margin: 5px;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    /* Physical control buttons */
    #controls {
      text-align: center;
      margin-bottom: 20px;
    }
    #controls button {
      padding: 10px 15px;
      font-size: 16px;
      margin: 0 5px;
    }
    /* Recycle bin area for resetting an individual tile */
    #recycle-bin {
      width: 100%;
      height: 50px;
      border: 2px dashed #666;
      margin: 10px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      color: #666;
    }
    /* Alphabet grid: 26 cells (one per letter) arranged in 13 columns */
    #alphabet-grid {
      display: grid;
      grid-template-columns: repeat(13, 1fr);
      gap: 10px;
    }
    .letter-cell {
      width: 70px;
      height: 70px;
      border: 1px dashed #aaa;
      position: relative;
      background-color: #f0f0f0;
    }
    /* Draggable tile styling */
    .tile {
      width: 70px;
      height: 70px;
      border: 1px solid #333;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 24px;
      font-weight: bold;
      user-select: none;
      touch-action: none; /* helps mobile dragging */
      cursor: pointer;
    }
    /* Pastel colors: pastel red for vowels, pastel blue for consonants */
    .tile.vowel {
      background-color: #ffcccc;
    }
    .tile.consonant {
      background-color: #ccccff;
    }
  </style>
</head>
<body>
  <!-- Word formation area (10 drop boxes) -->
  <div id="word-boxes">
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
    <div class="drop-box"></div>
  </div>

  <!-- Physical control buttons -->
  <div id="controls">
    <button id="speak-word">Speak Word</button>
    <button id="define-word">Define Word</button>
    <button id="reset-all">Reset All</button>
  </div>

  <!-- Recycle bin area -->
  <div id="recycle-bin">Drop tile here to reset</div>

  <!-- Alphabet grid: 26 cells, one per letter, each with a stack of 3 tiles -->
  <div id="alphabet-grid"></div>

  <script>
    // Global variables for drag management
    let currentDrag = null;
    const dragThreshold = 5; // pixels to move before initiating a drag
    const vowels = ['A','E','I','O','U'];

    // Utility: speak text using Web Speech API
    function speakText(text) {
      const utterance = new SpeechSynthesisUtterance(text);
      window.speechSynthesis.speak(utterance);
    }

    // Function to restack tiles in a cell (with a slight offset for each)
    function restackCell(cell) {
      const tiles = cell.querySelectorAll('.tile');
      tiles.forEach((tile, index) => {
        tile.style.position = "absolute";
        tile.style.left = (index * 5) + "px";
        tile.style.top = (index * 5) + "px";
        tile.style.zIndex = index;
      });
    }

    // Build the alphabet grid:
    // – One cell per letter (A–Z) arranged in a 13-column grid.
    // – In each cell, create three copies of that letter (stacked).
    const alphabetGrid = document.getElementById('alphabet-grid');
    const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
    // We'll also keep a mapping from letter to its cell for easy resets.
    const letterCells = {};
    letters.forEach(letter => {
      const cell = document.createElement('div');
      cell.classList.add('letter-cell');
      cell.dataset.letter = letter;
      letterCells[letter] = cell;
      // Create three tiles for this letter
      for (let i = 0; i < 3; i++) {
        const tile = document.createElement('div');
        tile.classList.add('tile');
        tile.textContent = letter;
        tile.dataset.letter = letter;
        // Apply color based on vowel/consonant
        if (vowels.includes(letter)) {
          tile.classList.add('vowel');
        } else {
          tile.classList.add('consonant');
        }
        // Store a reference to its home cell for resetting
        tile.homeCell = cell;
        // Add pointer event listeners
        tile.addEventListener('pointerdown', pointerDown);
        tile.addEventListener('pointermove', pointerMove);
        tile.addEventListener('pointerup', pointerUp);
        tile.addEventListener('pointercancel', pointerUp);
        cell.appendChild(tile);
      }
      // Stack the three tiles with a slight offset
      restackCell(cell);
      alphabetGrid.appendChild(cell);
    });

    // --- Pointer Event Handlers for Drag/Drop ---
    function pointerDown(e) {
      // Only allow one drag at a time
      if (currentDrag) return;
      const tile = e.currentTarget;
      const rect = tile.getBoundingClientRect();
      currentDrag = {
        tile: tile,
        startX: e.clientX,
        startY: e.clientY,
        // Record the offset from the tile’s top‑left where the pointer was pressed
        offsetX: e.clientX - rect.left,
        offsetY: e.clientY - rect.top,
        dragging: false,
        originalParent: tile.parentElement
      };
      tile.setPointerCapture(e.pointerId);
    }

    function pointerMove(e) {
      if (!currentDrag) return;
      const { tile, startX, startY, offsetX, offsetY, dragging } = currentDrag;
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (!dragging && dist > dragThreshold) {
        // Start the drag: reparent the tile to document.body
        currentDrag.dragging = true;
        // Recalculate offset based on current position (to reduce any jump)
        const rect = tile.getBoundingClientRect();
        currentDrag.offsetX = e.clientX - rect.left;
        currentDrag.offsetY = e.clientY - rect.top;
        document.body.appendChild(tile);
        tile.style.position = "fixed";
        tile.style.zIndex = 1000;
      }
      if (currentDrag.dragging) {
        // Update tile’s position so it stays under the finger
        tile.style.left = (e.clientX - currentDrag.offsetX) + "px";
        tile.style.top = (e.clientY - currentDrag.offsetY) + "px";
      }
    }

    function pointerUp(e) {
      if (!currentDrag) return;
      const { tile, startX, startY, dragging, originalParent } = currentDrag;
      tile.releasePointerCapture(e.pointerId);
      // If no significant movement occurred, treat this as a tap (speak the letter)
      const dx = e.clientX - startX;
      const dy = e.clientY - startY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (!dragging || dist < dragThreshold) {
        speakText(tile.textContent);
        currentDrag = null;
        return;
      }
      // When the drag ends, determine where the tile was dropped.
      const tileRect = tile.getBoundingClientRect();
      const tileCenter = {
        x: tileRect.left + tileRect.width / 2,
        y: tileRect.top + tileRect.height / 2
      };
      let dropped = false;
      // 1. Check if dropped in one of the word boxes (only if empty)
      document.querySelectorAll('.drop-box').forEach(box => {
        const rect = box.getBoundingClientRect();
        if (
          tileCenter.x >= rect.left &&
          tileCenter.x <= rect.right &&
          tileCenter.y >= rect.top &&
          tileCenter.y <= rect.bottom
        ) {
          if (box.children.length === 0) {
            // Snap tile into the word box
            tile.style.position = "static";
            tile.style.left = "";
            tile.style.top = "";
            tile.style.zIndex = "";
            box.appendChild(tile);
            dropped = true;
          }
        }
      });
      // 2. Check if dropped in the recycle bin area
      const recycleBin = document.getElementById('recycle-bin');
      const binRect = recycleBin.getBoundingClientRect();
      if (
        tileCenter.x >= binRect.left &&
        tileCenter.x <= binRect.right &&
        tileCenter.y >= binRect.top &&
        tileCenter.y <= binRect.bottom
      ) {
        // Return the tile to its home cell and restack that cell
        tile.style.position = "absolute";
        tile.style.left = "";
        tile.style.top = "";
        tile.style.zIndex = "";
        tile.homeCell.appendChild(tile);
        restackCell(tile.homeCell);
        dropped = true;
      }
      // 3. If not dropped in a valid zone, snap it back to its original parent
      if (!dropped) {
        tile.style.position = "absolute";
        tile.style.left = "";
        tile.style.top = "";
        tile.style.zIndex = "";
        originalParent.appendChild(tile);
        restackCell(originalParent);
      }
      currentDrag = null;
    }

    // --- Control Button Handlers ---
    document.getElementById('speak-word').addEventListener('click', () => {
      let word = "";
      document.querySelectorAll('.drop-box').forEach(box => {
        if (box.children.length > 0) {
          word += box.children[0].textContent;
        }
      });
      if (word) speakText(word);
    });

    document.getElementById('define-word').addEventListener('click', () => {
      let word = "";
      document.querySelectorAll('.drop-box').forEach(box => {
        if (box.children.length > 0) {
          word += box.children[0].textContent;
        }
      });
      if (word) {
        fetch("https://api.dictionaryapi.dev/api/v2/entries/en/" + word)
          .then(response => response.json())
          .then(data => {
            let definition = "";
            if (Array.isArray(data) && data.length > 0) {
              const meanings = data[0].meanings;
              if (meanings && meanings.length > 0) {
                const definitions = meanings[0].definitions;
                if (definitions && definitions.length > 0) {
                  definition = definitions[0].definition;
                  alert("Definition of " + word + ":\n" + definition);
                  speakText(definition);
                  return;
                }
              }
            }
            alert("Definition not found for " + word);
          })
          .catch(err => {
            alert("Error fetching definition for " + word);
          });
      } else {
        alert("No word formed.");
      }
    });

    document.getElementById('reset-all').addEventListener('click', () => {
      // Clear all word boxes
      document.querySelectorAll('.drop-box').forEach(box => {
        box.innerHTML = "";
      });
      // For every tile, return it to its home cell and restack that cell
      document.querySelectorAll('.tile').forEach(tile => {
        tile.style.position = "absolute";
        tile.style.left = "";
        tile.style.top = "";
        tile.style.zIndex = "";
        tile.homeCell.appendChild(tile);
        restackCell(tile.homeCell);
      });
    });
  </script>
</body>
</html>
